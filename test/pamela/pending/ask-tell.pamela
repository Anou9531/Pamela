;; Copyright Â© 2017 Dynamic Object Language Labs Inc.
;;
;; This software is licensed under the terms of the
;; Apache License, Version 2.0 which can be found in
;; the file LICENSE at the root of this distribution.

;;; Acknowledgement and Disclaimer:
;;; This material is based upon work supported by the Army Contracting
;;; and DARPA under contract No. W911NF-15-C-0005.
;;; Any opinions, findings and conclusions or recommendations expressed
;;; in this material are those of the author(s) and do necessarily reflect the
;;; views of the Army Contracting Command and DARPA.

;; Suggested use:
;; pamela -v -i ask-tell.pamela -o ask-tell -t "(main-no-modes.main)" htn

;; NOTE: Conditions with Modes aren't yet supported
;; So, use main-no-modes for now.
(defpclass main-with-modes []
  :modes {:running (= door "open")
          :stopped (= door "closed")}
  :methods [(defpmethod main []
              (parallel
               (ask (or (and (= door "open") :running)
                        (and (= door "closed") :stopped))
                    :bounds [5 30])
               (foo)
               ))

            ;; I would have liked to name this "tell-branch", but Issue #121 prevents this
            (defpmethod foo []
              (sequence
               (delay :bounds [6 6])
               (tell (= door "open"))))
            ])

(defpclass main-no-modes []
  :methods [(defpmethod main []
              (parallel
               ;; Simply wait until the state variable "door" is set
               (ask (or (= door "open")
                        (= door "closed"))
                    :bounds [5 30])
               (foo)
               ))

            ;; I would have liked to name this "tell-branch", but Issue #121 prevents this
            (defpmethod foo []
              (sequence
               (delay :bounds [6 6])
               (tell (= door "open"))))
            ])
