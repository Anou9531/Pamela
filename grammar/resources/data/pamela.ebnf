pamela = defpclass*
defpclass = <LP> <DEFPCLASS> symbol args option* <RP>

args = <LB> symbol* <RB>
option = ( meta | modes | fields | methods | transitions | observable | access)

meta = <META> <LM> meta-entry+ <RM>
meta-entry = ( VERSION string | ICON string | DEPENDS <LB> dep* <RB> | DOC string )
dep = <LB> symbol string <RB>

modes = <MODES> ( mode-enum | mode-map )
mode-enum = <LB> keyword* <RB>
mode-map = <LM> mode-init+ <RM>
mode-init = keyword ( TRUE | cond-fn )
cond-fn = <LP> <CONDITION> cond-expr <RP>
cond-expr = ( and-expr | or-expr | not-expr | implies-expr | field-expr | mode-expr )
and-expr = <LP> <AND> cond-expr+ <RP>
or-expr = <LP> <OR> cond-expr+ <RP>
not-expr = <LP> <NOT> cond-expr <RP>
implies-expr = <LP> <IMPLIES> cond-expr+ <RP>
field-expr = <LP> <FIELDEQ> keyword literal <RP>
mode-expr = <LP> <MODEEQ> keyword <RP>

fields = <FIELDS> <LM> field* <RM>
field = keyword field-init
field-init = ( symbol | lvar-ctor| pclass-ctor | pclass-helper )

methods = <METHODS> <LB> defpmethod* <RB>
defpmethod = <LP> <DEFPMETHOD> symbol cond-map? args fn? between-opt* <RP>

transitions = <TRANSITIONS> <LM> transition* <RM>
transition = keyword cond-map
cond-map =  <LM> cond* <RM>
cond = keyword ( keyword | string | number | symbol | lvar-ctor | cond-fn | bounds )

fn = ( ask | assert | choose | maintain | noop | parallel | plant-fn | sequence | tell | try-form | unless | when | whenever )

ask = <LP> <ASK> cond-fn opt-bounds? <RP>
assert = <LP> <ASSERT> cond-fn opt-bounds? <RP>
choice = <LP> <CHOICE> choice-opt* fn <RP>
choose = <LP> <CHOOSE> fn-opt* choice+ <RP>
maintain = <LP> <MAINTAIN> cond-fn opt-bounds? fn <RP>
noop = <LP> <NOOP> <RP>
parallel = <LP> <PARALLEL> fn-opt* fn+ <RP>
plant-fn = <LP> symbol <'$'> symbol fn-opt* argval* <RP>
sequence = <LP> <SEQUENCE> fn-opt* fn+ <RP>
tell = <LP> <TELL> cond-fn <RP>
try-form = <LP> <TRY-FORM> opt-bounds? fn <LP> <CATCH> fn <RP> <RP>
unless = <LP> <UNLESS> cond-fn opt-bounds? fn <RP>
when = <LP> <WHEN> cond-fn opt-bounds? fn <RP>
whenever = <LP> <WHENEVER> cond-fn opt-bounds? fn <RP>

between-opt = (between | between-ends | between-starts)

between = <LP> <BETWEEN> keyword keyword bounds <RP>
between-ends = <LP> <BETWEEN-ENDS> keyword keyword bounds <RP>
between-starts = <LP> <BETWEEN-STARTS> keyword keyword bounds <RP>

fn-opt = ( opt-bounds | opt-label )

choice-opt = ( opt-bounds | opt-probability | opt-cost | opt-reward | opt-guard | opt-label )

opt-bounds = <BOUNDS> bounds
opt-label = <LABEL> keyword
opt-probability = <PROBABILITY> number-ref
opt-cost = <COST> number-ref
opt-reward = <REWARD> number-ref
opt-guard = <GUARD> cond-fn

number-ref = ( symbol | lvar-ctor | number )

lvar-ctor = <LP> <LVAR> string? <RP>

initial = <INITIAL> keyword
observable = <OBSERVABLE> boolean
access = <ACCESS> keyword
id = <ID> string

pclass-ctor = <LP> symbol pclass-ctor-option* <RP>
pclass-helper = <LP> <PCLASS> symbol keyword* pclass-ctor-option* <RP>
pclass-ctor-option = ( initial | observable | access | id )

bounds = <LB> number ( number | INFINITY ) <RB>

argval = ( symbol | literal )
symbol = #'[A-Za-z0-9-]+'
literal = ( boolean | string | keyword | number )
keyword = #':[A-Za-z0-9:*-]+'
boolean = ( <TRUE> | <FALSE> )
string = #'".*"'
number = ( float | integer )
float = <'-'>? integer <'.'> integer
integer = #'-?[0-9]+'

ACCESS = <':access'>
AND = <'and'>
ASK = <'ask'>
ASSERT = <'assert'>
BETWEEN = <'between'>
BETWEEN-ENDS = <'between-ends'>
BETWEEN-STARTS = <'between-starts'>
BOUNDS = <':bounds'>
CATCH = <'catch'>
CHOICE = <'choice'>
CHOOSE = <'choose'>
CONDITION = <'condition'>
COST = <':cost'>
DEFPCLASS = <'defpclass'>
DEFPMETHOD = <'defpmethod'>
DEPENDS = <':depends'>
DOC = <':doc'>
FALSE = <'false'>
FIELDEQ = <'field='>
FIELDS = <':fields'>
GUARD = <':guard'>
ICON = <':icon'>
ID = <':id'>
IMPLIES = <'implies'>
INFINITY = <':infinity'>
INITIAL = <':initial'>
LABEL = <':label'>
LVAR = <'lvar'>
MAINTAIN = <'maintain'>
META = <':meta'>
METHODS = <':methods'>
MODEEQ = <'mode='>
MODES = <':modes'>
NOOP = <'noop'>
NOT = <'not'>
OBSERVABLE = <':observable'>
OR = <'or'>
PARALLEL = <'parallel'>
PCLASS = <'pclass'>
PROBABILITY = <':probability'>
REWARD = <':reward'>
SEQUENCE = <'sequence'>
TELL = <'tell'>
TRANSITIONS = <':transitions'>
TRUE = <'true'>
TRY-FORM = <'try-form'>
UNLESS = <'unless'>
VERSION = <':version'>
WHEN = <'when'>
WHENEVER = <'whenever'>

LP = <'('>
RP = <')'>
LB = <'['>
RB = <']'>
LM = <'{'>
RM = <'}'>
