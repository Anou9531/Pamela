(* PAMELA EBNF grammar *)

pamela = defpclass*
defpclass = <LP> <DEFPCLASS> symbol args option* <RP>

args = <LB> symbol* <RB>
option = ( meta | modes | fields | methods | transitions | observable | access)

meta = <META> <LM> meta-entry+ <RM>
meta-entry = ( VERSION string | ICON string | DEPENDS <LB> dep* <RB> | opt-doc )
dep = <LB> symbol string <RB>
opt-doc = DOC string

modes = <MODES> ( mode-enum | mode-map )
mode-enum = <LB> keyword* <RB>
mode-map = <LM> mode-init+ <RM>
mode-init = keyword ( TRUE | cond-fn )
cond-fn = <LP> <CONDITION> cond-expr <RP>
cond-expr = ( and-expr | or-expr | not-expr | implies-expr | field-expr | mode-expr )
and-expr = <LP> <AND> cond-expr+ <RP>
or-expr = <LP> <OR> cond-expr+ <RP>
not-expr = <LP> <NOT> cond-expr <RP>
implies-expr = <LP> <IMPLIES> cond-expr+ <RP>
field-expr = <LP> <FIELDEQ> keyword literal <RP>
mode-expr = <LP> <MODEEQ> keyword <RP>

fields = <FIELDS> <LM> field* <RM>
field = keyword field-init
field-init = ( symbol | lvar-ctor| !lvar-ctor pclass-ctor | pclass-helper )

methods = <METHODS> <LB> defpmethod* <RB>
defpmethod = <LP> <DEFPMETHOD> symbol cond-map? args fn? between-stmt* <RP>

transitions = <TRANSITIONS> <LM> transition* <RM>
transition = keyword trans-map
cond-map =  <LM> cond* <RM>
trans-map =  <LM> trans* <RM>
cond = ( opt-doc | opt-pre | opt-post | opt-bounds | opt-cost | opt-reward | opt-controllable )
trans = ( opt-doc | opt-pre | opt-post | opt-bounds | opt-cost | opt-reward | opt-probability )

opt-pre = <PRE> keyword
opt-post = <POST> keyword

fn = ( ask | assert | choose | optional | maintain | delay | parallel | slack-parallel | soft-parallel | plant-fn | sequence | slack-sequence | soft-sequence | tell | try-form | unless | when | whenever )

ask = <LP> <ASK> cond-fn opt-bounds? <RP>
assert = <LP> <ASSERT> cond-fn opt-bounds? <RP>
choice = <LP> <CHOICE> choice-opt* fn <RP>
choose = <LP> <CHOOSE> fn-opt* choice+ <RP>
optional = <LP> <OPTIONAL> fn-opt* fn <RP>
maintain = <LP> <MAINTAIN> cond-fn opt-bounds? fn <RP>
delay = <LP> <DELAY> delay-opt*  <RP>
parallel = <LP> <PARALLEL> fn-opt* fn+ <RP>
slack-parallel = <LP> <SLACK_PARALLEL> fn-opt* fn+ <RP>
soft-parallel = <LP> <SOFT_PARALLEL> fn-opt* fn+ <RP>
plant-fn = <LP> symbol <'$'> symbol plant-opt* argval* <RP>
sequence = <LP> <SEQUENCE> fn-opt* fn+ <RP>
slack-sequence = <LP> <SLACK_SEQUENCE> fn-opt* fn+ <RP>
soft-sequence = <LP> <SOFT_SEQUENCE> fn-opt* fn+ <RP>
tell = <LP> <TELL> cond-fn <RP>
try-form = <LP> <TRY-FORM> opt-bounds? fn <LP> <CATCH> fn <RP> <RP>
unless = <LP> <UNLESS> cond-fn opt-bounds? fn <RP>
when = <LP> <WHEN> cond-fn opt-bounds? fn <RP>
whenever = <LP> <WHENEVER> cond-fn opt-bounds? fn <RP>

between-stmt = (between | between-ends | between-starts)

between = <LP> <BETWEEN> keyword keyword between-opt+ <RP>
between-ends = <LP> <BETWEEN-ENDS> keyword keyword between-opt+ <RP>
between-starts = <LP> <BETWEEN-STARTS> keyword keyword between-opt+ <RP>

fn-opt = ( opt-label | opt-bounds | opt-cost-le | opt-reward-ge )
delay-opt = ( opt-label | opt-bounds | opt-cost-le | opt-reward-ge | opt-controllable )
between-opt = ( opt-bounds | opt-cost-le | opt-reward-ge )
plant-opt = ( opt-label | opt-bounds | opt-cost | opt-reward | opt-controllable )
choice-opt = ( opt-label | opt-bounds | opt-cost | opt-reward | opt-probability | opt-guard )

opt-bounds = <BOUNDS> bounds
opt-label = <LABEL> keyword
opt-probability = <PROBABILITY> number-ref
opt-cost = <COST> number-ref
opt-reward = <REWARD> number-ref
opt-cost-le = <COST_LE> number-ref
opt-reward-ge = <REWARD_GE> number-ref
opt-guard = <GUARD> cond-fn
opt-controllable = <CONTROLLABLE> boolean

number-ref = ( symbol | lvar-ctor | number )

lvar-ctor = <LP> <LVAR> string? <RP>

initial = <INITIAL> keyword
observable = <OBSERVABLE> boolean
access = <ACCESS> keyword
id = <ID> string

pclass-ctor = <LP> symbol pclass-ctor-option* <RP>
pclass-helper = <LP> <PCLASS> symbol keyword* pclass-ctor-option* <RP>
pclass-ctor-option = ( initial | observable | access | id )

bounds = <LB> number ( number | INFINITY ) <RB>

symbol = #'[A-Za-z][A-Za-z0-9-]*'
literal = ( boolean | string | keyword | number )
argval = ( symbol | boolean | string | number | safe-keyword )
safe-keyword = !reserved-keyword keyword
reserved-keyword = ( <LABEL> | <BOUNDS> | <COST> | <REWARD> | <CONTROLLABLE> )
keyword = <':'> #'[A-Za-z0-9:*-]+'
boolean = ( TRUE | FALSE )
string = <'"'>  #'[^"]*' <'"'>
number = ( float | integer )
float = integer <'.'> integer
integer = '-'? #'[0-9]+'

ACCESS = <':access'>
AND = <'and'>
ASK = <'ask'>
ASSERT = <'assert'>
BETWEEN = <'between'>
BETWEEN-ENDS = <'between-ends'>
BETWEEN-STARTS = <'between-starts'>
BOUNDS = <':bounds'>
CATCH = <'catch'>
CHOICE = <'choice'>
CHOOSE = <'choose'>
CONDITION = <'condition'>
CONTROLLABLE = <':controllable'>
COST = <':cost'>
COST_LE = <':cost<='>
DEFPCLASS = <'defpclass'>
DEFPMETHOD = <'defpmethod'>
DEPENDS = <':depends'>
DOC = <':doc'>
FALSE = <'false'>
FIELDEQ = <'field='>
FIELDS = <':fields'>
GUARD = <':guard'>
ICON = <':icon'>
ID = <':id'>
IMPLIES = <'implies'>
INFINITY = <':infinity'>
INITIAL = <':initial'>
LABEL = <':label'>
LVAR = <'lvar'>
MAINTAIN = <'maintain'>
META = <':meta'>
METHODS = <':methods'>
MODEEQ = <'mode='>
MODES = <':modes'>
DELAY = <'delay'>
NOT = <'not'>
OBSERVABLE = <':observable'>
OPTIONAL = <'optional'>
OR = <'or'>
PARALLEL = <'parallel'>
SLACK_PARALLEL = <'slack-parallel'>
SOFT_PARALLEL = <'soft-parallel'>
PCLASS = <'pclass'>
POST = <':post'>
PRE = <':pre'>
PROBABILITY = <':probability'>
REWARD = <':reward'>
REWARD_GE = <':reward>='>
SEQUENCE = <'sequence'>
SLACK_SEQUENCE = <'slack-sequence'>
SOFT_SEQUENCE = <'soft-sequence'>
TELL = <'tell'>
TRANSITIONS = <':transitions'>
TRUE = <'true'>
TRY-FORM = <'try-form'>
UNLESS = <'unless'>
VERSION = <':version'>
WHEN = <'when'>
WHENEVER = <'whenever'>

LP = <'('>
RP = <')'>
LB = <'['>
RB = <']'>
LM = <'{'>
RM = <'}'>
